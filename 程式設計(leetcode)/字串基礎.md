## 超級簡單題
### 242Valid Anagram
- Anagram：同樣的數量字母，去做不同排列
- 解法1：排序後比對
```cpp
class Solution {
public:
	// 解法1
    bool isAnagram(string s, string t) {
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s == t;
    }
};
```
- 解法2：map紀錄次數
```cpp
class Solution {
public:
    // 解法2：map
    bool isAnagram(string s, string t) {
        map<char, int> m;
        for(char c:s)m[c]++;
        for(char c:t){
            if(m.count(c)){
                m[c]--;
                if(m[c]==0) m.erase(c);
            }
            else return false;
        }
        return m.empty();
    }
};
```
## 模擬
### 13. Roman to Integer
- 小的在大的左邊：相減 => 可以想成加一個負號
- 小的在大的右邊：相加
```cpp
class Solution {
public:
    // 做map
    map<char, int> m = {
        {'I', 1},
        {'V', 5},
        {'X', 10},
        {'L', 50},
        {'C', 100},
        {'D', 500},
        {'M', 1000},
    };
    int romanToInt(string s) {
        int ans = 0;
        int n = s.size();
        for(int i=0;i<n-1;i++){
            // 取數值
            int x = m[s[i]];
            int y = m[s[i + 1]];
            if(x<y) x = -(x);
            ans += x;
        }
        ans += m[s[n-1]];
        return ans;
    }
};
```
### 14. Longest Common Prefix
- 每次都跟第一個去比較
```cpp
class Solution {
public:
    string f(string& s1, string& s2){
        int n = min(s1.size(), s2.size());
        int index = 0;
        while(index < n && s1[index] == s2[index]){
            index++;
        }
        return s1.substr(0, index);
    }

    string longestCommonPrefix(vector<string>& strs) {
        int n = strs.size();
        string ans = strs[0];
        for(int i=1;i<n;i++){
            // NOTE: 每次都跟第0個比
            ans = f(ans, strs[i]);
            if(ans == "") break;
        }
       
        return ans;
    }
};
```

### 58. Length of Last Word
- 不用套件
![upgit_20241112_1731409811.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241112_1731409811.png)

```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        int i = s.size()-1;
        while(s[i]==' ') i--;
        int j = i-1;
        while(j>-1 && s[j]!=' ') j--;
        return i-j;
    }
};
```



## 雙指針
### 125. Valid Palindrome
- 整理字串+測驗回文
```cpp
class Solution {
public:
    // 解法1
    bool isPalindrome(string s) {
        string s_temp;
        // 檢查是否為字串
        for(char ch:s){
            if(isalnum(ch)){
                s_temp+=tolower(ch);
            }
        }
        // 檢查回文
        string s_reverse = s_temp;
        reverse(s_reverse.begin(), s_reverse.end());
        return s_reverse == s_temp;
    }
};
// Your runtime beats 28.54 % of cpp submissions
// Your memory usage beats 11.04 % of cpp submissions (9.6 MB)
```
- 解法2：
```cpp
class Solution {
public:
    // 解法2：雙指針
    bool isPalindrome(string s) {
        int n = s.size();
        int left = 0, right = n-1;
        while(left<right){
            // 處理左指針不符規範(不是數值，就繼續縮)
            while(left<right && !isalnum(s[left])) left++;
            // 處理右指針不符規範
            while(left<right && !isalnum(s[right])) right--;
            // 檢查回文
            if(left<right){
                if (tolower(s[left]) != tolower(s[right])) return false;
                left++;
                right--;
            }
        }
        return true;
    }
};
// Your runtime beats 100 % of cpp submissions
// Your memory usage beats 52.4 % of cpp submissions (9 MB)
```
## map(雙向映射)
### 205. Isomorphic Strings
- 他比較的是一個數量，所以要用map紀錄。
- 這一題要開兩個map做雙向映射。
	- map_A的key為s，value為t
	- map_B的key為t，value為s
```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        map<char, char>s2t, t2s;
        int n = s.size(); // 題目有說s跟t長度依樣
        for(int i=0;i<n;i++){
            char x = s[i], y = t[i];
            if((s2t.count(x) && s2t[x]!=y) || (t2s.count(y) && t2s[y]!=x)){
                return false;
            }
            // 紀錄
            s2t[x] = y;
            t2s[y] = x;
        }
        return true;
    }
};
```
### 290. Word Pattern
```cpp
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        map<char, string> p2s;
        map<string, char> s2p;
        int n = s.size();  // 這邊一定要以s為長度，因為後面的ij都是用他判斷
        // 針對字串s要做切割 -> i頭j尾巴
        int i=0;
        string s_temp = "";
        for(char ch:pattern){
            // 如果已經超過字串 s 的長度，返回 false -> 根據最後【i = j + 1;】
            if (i >= n) return false;

            int j = i; // 宣告尾巴
            while(j<n && s[j]!=' ')j++;
            s_temp = s.substr(i, j - i);
            // 雙向映射，就跟205一樣
            if(p2s.count(ch) && p2s[ch]!=s_temp) return false;
            if(s2p.count(s_temp) && s2p[s_temp]!=ch) return false;
            p2s[ch]=s_temp;
            s2p[s_temp]=ch;
            // 往下一個新單字 
            i = j + 1;
        }
        return i>=n;
    }
};
```



## 數學
### 171. Excel Sheet Column Number
```cpp
class Solution {
public:
    int titleToNumber(string columnTitle) {
        int ans = 0;
        for(int i=0;i<columnTitle.size();i++){
            ans*=26;
            ans += columnTitle[i]-'A'+1; 
        }
        return ans;
    }
};
```
### 168. Excel Sheet Column Title
![upgit_20241112_1731413754.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241112_1731413754.png)

- 10進制轉26進制
```cpp
class Solution {
public:
    string convertToTitle(int columnNumber) {
        string ans;
        while(columnNumber > 0){
            columnNumber--;
            ans+=columnNumber%26 + 'A';
            columnNumber/=26;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

## KMP 演算法

### 28. Find the Index of the First Occurrence in a String
- 解法1：樸素比對
```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size(), m = needle.size();
        for (int i = 0; i + m <= n; i++){
            bool flag = true;
            // 逐一比對
            for (int j = 0; j < m; j++){
                if (haystack[i + j] != needle[j]){
                    flag = false;
                    break;
                }
            }
            if (flag) return i;
        }
        return -1;
    }
};
```
- 解法2：KMP 演算法(真滴難離解)
![upgit_20241112_1731388553.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241112_1731388553.png)

![upgit_20241112_1731388451.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241112_1731388451.png)

```cpp
class Solution {
public:
    // TODO: 製作next array
    void getNext(int next[], const string &needle){
        int j = -1;
        next[0] = -1;
        for(int i=1;i<needle.size();i++){
            while (j>-1 && needle[i] != needle[j+1]) j = next[j];
            if(needle[i] == needle[j+1]) j++;
            // 紀錄
            next[i] = j;
        }
    }

    int strStr(string haystack, string needle) {
        // 宣告next陣列
        int next[needle.size()];
        getNext(next, needle);
        int j = -1;
        for(int i=0;i<haystack.size();i++){
            // 不匹配
            while (j>-1 && haystack[i] != needle[j+1]) j = next[j];
            if(haystack[i] == needle[j+1]) j++;
            if(j == needle.size()-1) return (i-needle.size()+1);
        }
        return -1; // 未找到匹配
    }
};
```















