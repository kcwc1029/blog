## 模擬
### 13. Roman to Integer
- 小的在大的左邊：相減 => 可以想成加一個負號
- 小的在大的右邊：相加
```cpp
class Solution {
public:
    // 做map
    map<char, int> m = {
        {'I', 1},
        {'V', 5},
        {'X', 10},
        {'L', 50},
        {'C', 100},
        {'D', 500},
        {'M', 1000},
    };
    int romanToInt(string s) {
        int ans = 0;
        int n = s.size();
        for(int i=0;i<n-1;i++){
            // 取數值
            int x = m[s[i]];
            int y = m[s[i + 1]];
            if(x<y) x = -(x);
            ans += x;
        }
        ans += m[s[n-1]];
        return ans;
    }
};
```
### 14. Longest Common Prefix
- 每次都跟第一個去比較
```cpp
class Solution {
public:
    string f(string& s1, string& s2){
        int n = min(s1.size(), s2.size());
        int index = 0;
        while(index < n && s1[index] == s2[index]){
            index++;
        }
        return s1.substr(0, index);
    }

    string longestCommonPrefix(vector<string>& strs) {
        int n = strs.size();
        string ans = strs[0];
        for(int i=1;i<n;i++){
            // NOTE: 每次都跟第0個比
            ans = f(ans, strs[i]);
            if(ans == "") break;
        }
       
        return ans;
    }
};
```

### 58. Length of Last Word
- 不用套件
![upgit_20241112_1731409811.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241112_1731409811.png)

```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        int i = s.size()-1;
        while(s[i]==' ') i--;
        int j = i-1;
        while(j>-1 && s[j]!=' ') j--;
        return i-j;
    }
};
```



## 雙指針
### 125. Valid Palindrome
- 整理字串+測驗回文
```cpp
class Solution {
public:
    // 解法1
    bool isPalindrome(string s) {
        string s_temp;
        // 檢查是否為字串
        for(char ch:s){
            if(isalnum(ch)){
                s_temp+=tolower(ch);
            }
        }
        // 檢查回文
        string s_reverse = s_temp;
        reverse(s_reverse.begin(), s_reverse.end());
        return s_reverse == s_temp;
    }
};
// Your runtime beats 28.54 % of cpp submissions
// Your memory usage beats 11.04 % of cpp submissions (9.6 MB)
```
- 解法2：
```cpp
class Solution {
public:
    // 解法2：雙指針
    bool isPalindrome(string s) {
        int n = s.size();
        int left = 0, right = n-1;
        while(left<right){
            // 處理左指針不符規範(不是數值，就繼續縮)
            while(left<right && !isalnum(s[left])) left++;
            // 處理右指針不符規範
            while(left<right && !isalnum(s[right])) right--;
            // 檢查回文
            if(left<right){
                if (tolower(s[left]) != tolower(s[right])) return false;
                left++;
                right--;
            }
        }
        return true;
    }
};
// Your runtime beats 100 % of cpp submissions
// Your memory usage beats 52.4 % of cpp submissions (9 MB)
```

## 數學
### 171. Excel Sheet Column Number
```cpp
class Solution {
public:
    int titleToNumber(string columnTitle) {
        int ans = 0;
        for(int i=0;i<columnTitle.size();i++){
            ans*=26;
            ans += columnTitle[i]-'A'+1; 
        }
        return ans;
    }
};
```
### 168. Excel Sheet Column Title
![upgit_20241112_1731413754.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241112_1731413754.png)

- 10進制轉26進制
```cpp
class Solution {
public:
    string convertToTitle(int columnNumber) {
        string ans;
        while(columnNumber > 0){
            columnNumber--;
            ans+=columnNumber%26 + 'A';
            columnNumber/=26;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

## KMP 演算法

### 28. Find the Index of the First Occurrence in a String
- 解法1：樸素比對
```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size(), m = needle.size();
        for (int i = 0; i + m <= n; i++){
            bool flag = true;
            // 逐一比對
            for (int j = 0; j < m; j++){
                if (haystack[i + j] != needle[j]){
                    flag = false;
                    break;
                }
            }
            if (flag) return i;
        }
        return -1;
    }
};
```
- 解法2：KMP 演算法(真滴難離解)
![upgit_20241112_1731388553.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241112_1731388553.png)

![upgit_20241112_1731388451.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241112_1731388451.png)

```cpp
class Solution {
public:
    // TODO: 製作next array
    void getNext(int next[], const string &needle){
        int j = -1;
        next[0] = -1;
        for(int i=1;i<needle.size();i++){
            while (j>-1 && needle[i] != needle[j+1]) j = next[j];
            if(needle[i] == needle[j+1]) j++;
            // 紀錄
            next[i] = j;
        }
    }

    int strStr(string haystack, string needle) {
        // 宣告next陣列
        int next[needle.size()];
        getNext(next, needle);
        int j = -1;
        for(int i=0;i<haystack.size();i++){
            // 不匹配
            while (j>-1 && haystack[i] != needle[j+1]) j = next[j];
            if(haystack[i] == needle[j+1]) j++;
            if(j == needle.size()-1) return (i-needle.size()+1);
        }
        return -1; // 未找到匹配
    }
};
```















