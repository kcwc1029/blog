- process：正在執行的程式(program)
- 內容交換(context switching)：將舊的process儲存，並載入新process
- 虛擬記憶體(virutal memory)：允許program size大於實際memory大小，但program仍能執行。
	- 需求分頁(demand paging)：將program拆成多個page，有需要用到的page才載入到memory。
	- 分頁失誤(page fault)：當執行中的工作，存取不在memory中的page時，就發生page fault，需要花費一定時間，將工作從harddisk載入到memory。

## 1. 作業系統簡介
### 1.1. OS目的
- 以使用者觀點：做為電腦使用者(User)與電腦硬體(Hardware)之間的介面，使得User易於使用Hardware。
- 以系統觀點：
	- 是一個資源分配者(Resource Allocator)
	- 監控User Program的執行,以防止不正常的運作造成對系統的危害
### 1.2. 裸機vs延伸機
- 裸機(Bare Machine)：由硬體元件所組成,沒有任何附加的系統軟體。
- 延伸機器(Extended Machine)：在Bare Machine上加入OS、應用程式等。

![upgit_20250223_1740313290.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740313290.png)

### 1.3. 系統內運行的job有分為兩種
- IO bound job（IO 限制型工作）
	- 主要是依賴 I/O 操作（讀取/寫入磁碟、網路請求等），而非 CPU 運算。
	- CPU 的執行時間較少，大多時間都在等待 I/O 操作完成。
- cpu bound job（CPU 限制型工作）
	- 主要是依賴 CPU 運算，而不是 I/O 操作。
	- I/O 操作少，CPU 需要大量的運算時間。


### 1.4. 早期作業系統
- 人為安排工作順序
- 只有hardware，工程師寫出program後，交給作業員經由控制台來執行。
- 產生問題：
	- 因為人為借入，CPU閒置時間(CPU Idle Time)過長，導致最終process完成的時間很難預估
	- I/O運作時間太慢，導致CPU閒置時間(CPU Idle Time)過長
- 解法：
	- 利用常駐監督程式(resident moniter)：安排工作的執行順序
	- 讓一些設備介入CPU與IO之間(讓CPU與IO同時運作)。eg：off-line、buffering、spooling
	- 讓CPU保持busy。eg：multi-programming 
- 常駐監督程式(resident moniter)
- ![upgit_20250223_1740313678.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740313678.png)



#### 1.4.1. Off-Line處理
![upgit_20250223_1740314112.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740314112.png)

- 定義：如何讓 CPU 與慢速 I/O 設備更有效率地協作，以減少 CPU 的空閒時間（Idle Time）。
- 優點
	- 資源利用度高
	- 若運作配合的好，CPU Idle Time降低。
- 缺點
	- type需要人為安裝拆卸
	- type僅支援循序存取(機械動作=>慢)
#### 1.4.2. buffering
![upgit_20250223_1740314655.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740314655.png)

- 概念：Buffering（緩衝） 是一種透過 緩衝區（Buffer） 來改善 CPU 與 I/O 設備之間速度不匹配的技術。
- 若cpu bound job放到buffer中執行，可能會遇到兩種狀況，進而導致IO閒置。
	- IO設備面對滿的input buffer而被迫等待。
	- IO設備面對空的output buffer而被迫等待。
- 因此，以資源利用角度來看，IO bound job與cpu bound job需要均勻混合，才能是cpu與IO設備能充分被利用。
- 缺點：
	- buffering僅能讓單一process的CPU計算與IO操作同時執行
	- 僅能處理單一作業。如果把不同作業的數據放進同一個 buffer，系統無法分辨這些數據分別來自哪個作業。
	- 假設 作業 A 和 作業 B 同時輸出數據，若都寫到同一個 buffer，當列印機開始列印時，列印的順序和內容可能會交錯，造成錯誤輸出。
#### 1.4.3. spooling(線上同時周邊處裡，Simultaneous Peripheral Operation On- Line Processing)
![upgit_20250223_1740314890.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740314890.png)
- Spooling 是一種透過磁碟作為緩衝區的技術，允許 CPU 計算與 I/O 設備的操作同時進行。
- 每個 I/O 設備都有自己的 Spooling 區域，這些區域用來暫存數據，避免 CPU 受限於慢速 I/O 設備。
- disk上互有一張table記錄了 I/O 數據的存放位置，確保作業可以正確地讀取對應的資料。
- 磁碟上的 Spool 區域會按作業劃分成獨立的數據塊，每個作業的數據都單獨存放。
- 作業 A 的數據存放在磁碟的區域 1，作業 B 的數據存放在區域 2。列印機從磁碟按順序讀取數據，逐一處理。
- 優點
	- CPU計算與IO設備可以同時執行
-  缺點：
	- OS需要花費一些memory來記錄各項IO之間執行狀況
	- disk需要花費一些memory來存放table

![upgit_20250223_1740314972.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740314972.png)


### 1.5. 系統類型(system type)
#### 1.5.1. process同時進行的方式：Concurrent & Parallel
![upgit_20250223_1740315152.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740315152.png)

- Concurrent(並行)
	- 在單一時間點只有一個Process在執行 
	- 強調的是一段執行時間內,有多Process同時執行
	- 單一顆CPU即可做到。
	- Multiprogramming System
- Parallel(平行)
	- 在單一時間點有很多的Process在執行
	- 需要多科CPU
#### 1.5.2. Multiprogramming System
- 目標：避免 CPU 閒置（CPU Idle），提高 CPU 使用率（CPU Utilization）。
- 透過 CPU Scheduling（CPU 排程） 來決定哪個 Process 可以獲得 CPU 的執行權。
- Multiprogramming System 的 OS 需求
	- 需要作業系統安排行程給cpu => cpu scheduling
	- 決定哪些資料要放memory，那些要放harddisk => job scheduling
	- 我們要將多個要執行的Process放到memory，其中需要記憶體管理機制來存放記憶體輪流執行的工作。
##### 1.5.2.1. Multiprogramming Degree（多道程度）
- 定義：指的是 系統中同時存在的「等待執行的 Process 數量」。
- Multiprogramming Degree 越高，CPU 使用率（CPU Utilization）越高。

#### 1.5.3. Time-Sharing System(分時系統)
- 也是Multiprogramming System的一種
- 透過資源共享(resource sharing)使每個user都有專屬的系統
	- 共享cpu：透過cpu scheduling
	- 共享memory space
	- 透過spooling 共享IOdvice
#### 1.5.4. 分散式系統(Distributed System)
- 定義：多個處理單元（CPU）共同協作完成計算
- 分為 緊密耦合（Tightly Coupled, Multiprocessing） 和 鬆散耦合（Loosely Coupled, Distributed System） 兩種類型。
##### 1.5.4.1. tightly coupled(緊密耦合)：Multiprocessing
- 特徵：同一台機器擁有多顆 CPU，共享memory、IO；bus => 合乎經濟效益(Economy of Scale)。
	- 受同一個clock、OS控制與協調
	- cpu之間的溝通採share memory技術
	- 將多個process(或一個process裡面的subtask)配置到多個CPU上，採Parallel方式執行，提升產能(Increased Throughput)。
- 若有n個CPU，效率並非提升n倍：CPU之間的communication及資源競爭(resource contention)會產生額外消耗。
##### 1.5.4.2. loosely coupled(鬆散耦合)：Distributed System
- 特徵：多台機器，每台都有獨立的 CPU、記憶體、I/O 設備
	- 透過訊息傳遞（Message Passing） 來交換資料，而不是共享記憶體。
- 機器之間通訊： 以訊息傳遞(messeng passing)方式為主，機器之間以network或高速bus連接。
- 可以分為
	- client-server model
	- peer to peer model：每一部電腦都可以是client/server
#### 1.5.5. 硬性及時系統(hard real time System)
- 定義嚴謹的固定時間限制，若process未能在規定時間內完成，process即屬失效。
- 用於自動工業化、軍事、核能安控
- OS不用太強，但application program設計很重要
#### 1.5.6. 軟性及時系統(soft real time System)
- 增加priority機制。
- 具有即時性的process讓他有最高的priority
- CPU scheduling要可以支援priority scheduling，但不能提供aging技術(讓process priority可以逐漸提高)。
- 宜避免優先權反轉問題(priority inversion)，可以用優先權繼承(priority inheritance)來解決。


> [!NOTE] 優先權反轉問題(priority inversion)
> 當一個較高priority的process突然被排進schedule，原先在CPU內較低的process就會被趕進memory，讓CPU先執行較高priority的process。
> 
> 但突然較高priority的process他所需要的資料，又在較低的process手中，就尷尬了

> [!NOTE] 優先權繼承(priority inheritance)
> 暫時性調高low priority process


#### 1.5.7. 叢集式系統（Clustered System）
- 叢集式系統（Clustered System） 與 平行系統（Parallel System） 類似，都是 透過多個 CPU 來完成計算工作。
- 與平行系統的不同點：Clustered System 是由兩台或多台獨立的電腦或系統 透過網路（LAN） 集結成一個系統來協同工作。
- 特性：
	- 共享儲存設備：確保數據同步。
	- 若其中一台機器故障，其他機器可以接管工作，確保系統運行不中斷
	- 平行計算（Parallel Computing）(電影《阿凡達》使用 500 多台 Clustered System 來渲染動畫)
- 以監督角度可分為：
	- 非對稱式(Asymmetric Clustering)：有一台機器處於熱待機狀態(hot stand-by mode)，都有一台壞掉，就馬上補上去
	- 對稱式(Symmetric Clustering)：多部彼此進行，互相監督。具有較高處理效能。
#### 1.5.8. Handheld System
- 個人數位助理(Personal Digital Assistant, PDA)或手機
- 受限於硬體大小
	- Limited memory(有限的記憶體)：並沒有虛擬記憶體技術
	- Slow processors(處理速度較慢的處理器)
	- Small display screens(較小的顯示器)
## 2. 電腦系統架構
![upgit_20250223_1740316961.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740316961.png)

- 每一個裝置都會有一個Derice Controller(disk會有disk Controller，滑鼠、鍵盤、印表機(printer)會有USB Controller。)
- IO devices和CPU可以同時執行並競爭Memory。
- 每一個Device Controller有自已的local buffer。
- 系統中發生一個事件時，通常是硬體或軟體產生中斷(interrupt)來通知。

### 2.1. 中斷(interrupt)
- 每個PC都會有自己的中斷技術
- OS area會存在：
	- 中斷向量表(Interrupt Vector)：包含InterruptID、ISR的起使位置。
	- 中斷服務程式(Interupt Service Routine; ISR)：當中斷發生時，CPU會依據中斷向量表去找到對應的ISR執行。
![upgit_20250223_1740317251.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740317251.png)

 - 中斷發生處理步驟：
	 - CPU暫停當前process，並保存狀態。
	 - 根據InterruptID去找ISR起始位置。
	 - jump to 對應ISR
	 - 執行ISR
	 - ISR執行完畢，將控制權還給OS
	 - (理論上)回復原先中斷的process。
#### 2.1.1. 中斷的種類
- external Interrupt：
	- 由CPU以外的周邊設備引起
	- machine check、IO complete、device error
- internal Interrupt：
	- 由CPU本身引發
	- overflow、除0
- software Interrupt(又稱為陷阱(trap))：
	- 當precess在執行過程中，若需要OS提供外部服務，這時precess就會像OS發送中斷，提供所指定的service，
	- 這時，硬體發出signal，軟體發出system call。


> [!NOTE] Interrupt vs trap
> Interrupt：IO裝置發出IO complete中斷
> trap：process需要OS時發出，像是錯誤數學運算


### 2.2. CPU與IO的運作方式
- 三種：polling IO、 interrupt IO、DMA
#### 2.2.1. IO 裝置的組成
- IO 裝置主要由以下部分組成：
	- 機械部分：如磁臂等物理部件。
	- 電子控制部分 (controller)：負責接收與處理 CPU 指令。
		- General register：負責接收 CPU 發送的指令，如 IO 命令 (Interrupt)。
		- Buffer register：在資料傳送時用作暫存空間。
#### 2.2.2. polling IO
1. CPU正在執行process1
2. process1向OS發送IO request
3. OS透過CPU設定 IO command to general register
4. IO運作
5. process1進入等待
6. CPU切給process2執行
7. CPU會不斷詢問IO device是否做完(CPU會在process2跟IO device之間來回切換)。
	- CPU需要花費很大時間監控IO
	- CPU未能全部投入在process2，浪費很多polling time
	- 對process2產能無異
#### 2.2.3. interrupt IO
- 前期跟polling IO一樣。但CPU不會監控IOdevice是否做完
- 當 IO 任務完成，IO 控制器會發出一個 "IO complete" 中斷訊號 通知 OS。
- OS 接收中斷並處理：OS 根據 中斷 ID 查找對應的 ISR（Interrupt Service Routine，中斷服務程序） 來處理這個中斷。
	- OS 通知 process1：你的 IO 任務已完成
	- 將 process1 從「等待 (wait)」改成「準備 (ready)」，表示它可以再次執行。
- 依據CPU排班恢復process1執行
#### 2.2.4. 直接記憶體存取(direct memory access, DMA)
- DMA Controller（DMA控制器）是一個專門的硬體模組，負責在記憶體與IO裝置之間進行資料傳輸。傳輸過程中，CPU並不參與實際的資料搬移
- 儘管CPU不直接介入資料傳輸，DMA完成整個資料傳輸後仍會發出中斷通知作業系統，不過發出中斷的時點與傳統的interrupt IO有所不同。
- 在進行DMA資料傳輸之前，CPU需要設定DMA控制器，主要設定項目包括：
	- IO command(讀寫)：告知DMA控制器此次操作是進行讀取還是寫入。
	- physical device location：指定資料來源或目的地的硬體位置。
	- memory location：定義資料在記憶體中的存放起始地址
	- counter(傳輸量得大小)：傳輸量到達之後才會發出中斷。
- 有無DMA controller區別
![upgit_20250223_1740319102.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740319102.png)

#### 2.2.5. CPU與DMA之間對memory的運作方式
- 用交替(interleaving)方式 => 週期偷取(cycle stealing)
- 週期偷取(cycle stealing) ：主要目的是在不影響 CPU 正常工作的前提下，讓 DMA 可以訪問系統記憶體，進行資料傳輸。
	- CPU 優先處理：當 CPU 需要訪問記憶體時，記憶體的訪問權會優先分配給 CPU。
	- 在 CPU 不需要訪問記憶體的時刻，DMA 控制器會「偷取」這些空閒週期來訪問記憶體。
		- 這些偷取的週期非常短暫，對 CPU 幾乎沒有影響。
- 若CPU與DMA發生memory conflict(衝突)時，OS會給予DMA controller較高的優先權(資源服務要求較少的process先做)
### 2.3. stroage structure
- main memory
	- cpu唯一能夠直接存取的外部儲存區域
	- 容量小，去揮發性(volatile)

| RAM                  | ROM              |
| -------------------- | ---------------- |
| random access memory | read only memory |
| 資料可以隨意存取             | 只讀不寫             |
| 有揮發性                 | 無揮發性             |
| 容量大                  | 容量小              |
| DDR RAM              |                  |

- 輔助儲存體：具非揮發性的大容量記憶體

![upgit_20250223_1740319802.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250223_1740319802.png)

### 2.4. 暫存器(register)
- 程式計數器(program counter, PC)：保存下一條將被執行指令在記憶體中的地址
- 指令暫存器(Instruction Register, IR)：暫存當前正在執行的指令
- 記憶體資料暫存器(Memory Data Register, MDR)：暫存從記憶體中讀取或寫入記憶體的數據
- 記憶體位址暫存器(Memory Address Registerm MAR)：保存需要訪問的記憶體地址
- 行程狀態字元(Process Status Word, PSW)：紀錄ALU執行指令後的狀態
- 基底暫存器/限制暫存器(Base Register/Limit Register)：用於記憶體地址的範圍檢查
	- Base Register：紀錄program執行的起始大小
	- Limit Register：紀錄program所需記憶體大小
### 2.5. 快取記憶體(cache)
- 改善CPU對主記憶體之存取速度。
- 將記憶體中經常被存取的區域之內容置於Cache Memory中，若CPU要的資料沒有在cache中，才會再去memory中去找。
- 硬體分為兩種：
	- 內建在CPU中的L1快取
	- 在CPU之外(主機板)的L2快取

> [!NOTE] memory更新策略
> 在multiprocessor的環境下，由於不同process與CPU能夠並行執行，如果資料更新，更新後的一致性問題是一個重大考驗。尤其在分散式(distribute)下更是常見議題。
> 
> write though：改寫cache時，立刻寫回memory
   優點：cache與memory內容一致
   缺點：耗時
>
>write back：cache被置換出去時，才會將改寫內容寫回memory
>優點：節省時間
>缺點：cache可能與memory內容不一致

### 2.6. IO structure
- 探討：當user process發出IO request後，系統的控制權多久會交給user process
- Synchronous I/O
	- 當程式發出 I/O 請求，該 Process 會進入等待狀態，直到 I/O 完成後才能繼續執行。
	- Busy Waiting：CPU 不斷輪詢（Polling）I/O 設備的狀態，直到 I/O 完成
	- Wait Instruction：CPU 讓出控制權，將 Process 轉為「等待狀態」（Blocked State），直到 I/O 完成時被喚醒。
- Asynchronous I/O
	- 當程式發出 I/O 請求 後，不需要等待 I/O 完成，而是繼續執行其他工作
	- 當 I/O 完成時，作業系統透過 中斷（Interrupt）或 回調函式（Callback Function） 來通知應用程式。
	- 一段時間內可能有多個IO同時發生 => OS必須有一個device status table 來記錄各種device位置、使用狀況、位於某device的IO請求狀況

### 2.7. 硬體保護(hardeware Protection)
- 前提：基礎設施
	- 雙模式運作(Dual-Mode Operation)
	- 特權指令(Privileged Instruction)
- 用在：IO Protection、memory Protection、CPU Protection

#### 2.7.1. Dual-Mode
- 目的：
	- 保護作業系統不受User Program之破壞
	- 保護User Program之間不會相互干擾。
- 分為兩種模式：
	- 監督模式(monitor mode)
		- 只有OS相關的system program可以執行(user program不行)
		- 此模式可以執行特權指令(Privileged Instruction)
	- 使用者模式(user mode)
		- User Programs在此模式下執行
		- 但User Programs並不能對硬體存取(或修改系統設定的權限)
		- 只能存取作業系統提供的 API請求 OS 來執行 =>系統呼叫 (System Call)
- 將可能引起系同危害的指令設定為特權指令(Privileged Instruction)
- Dual-Mode需要額外硬體支援，也就是提供一個模式位元(mode bit)區分兩種模式，0表示monitor mode、1表示user mode
#### 2.7.2. 特權指令(Privileged Instruction)
- 種類：
	- IO指令(IO device是重要資源)
	- 與記憶體管理有關的占存器之修改指令
	- 與timer有關指令
	- enable/disable interrupt指令
	- 系統停止(halt)指令
	- 從user mode改變到monitor mode的指令 => trap
#### 2.7.3. I/O Protection：
![upgit_20250224_1740400969.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250224_1740400969.png)
- 目的：防止user program直接使用IO設備
- user program透過system call(也會伴隨一些trap) 提出IO request，由OS控制IO運作，並將IOresult告知user program

> trap：通知OS我要求一個服務
>  system call：通知OS我要求甚麼服務

#### 2.7.4. 補充：綁定(binding)
- 定義：決定程式執行的起始位置(也就是程式要在記憶體的哪個地方開始執行)是在甚麼時其決定的。
- binding的三個時間點：(不同時間點，會有不同效益)
	- Compiling Time(編輯時期)
	- Loading Time(載入時期)
	- Execution Time(執行時期)
![upgit_20250224_1740401839.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250224_1740401839.png)

#### 2.7.5. Memory Protection：
- 目的：防止user program誤用記憶體 => 保護Monitor(0.S.)所在的區域不被User Program修改。
- 兩種做法：
	- 使用Fence Register(界限占存器)
	- 讓Monitor Area與User Area往相反方向增長
![upgit_20250224_1740402891.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250224_1740402891.png)

- 對於每個user area的保護：每一個user area都要有
	- base register：用來記錄user program 的期使位置
	- limit register：用來記錄user program 的大小
![upgit_20250203_1738591701.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250203_1738591701.png)

#### 2.7.6. CPU Protection：
- 防止user program無限期占用CPU
- 各個User Area的保護：對各個User Program所在的Memory Area進行保護，以防止User Program之間企圖更改其它User Program所在的Memory Area。
- OS會規定出一個user Program使用CPU time 的合理最大值。
- 當timer時間到，timer會發出一個time out的interrupt通知OS，此時可以強迫process放棄CPU
- timer值的設定也必須設定為特權指令

## 3. 作業系統架構

### 3.1. 系統呼叫(system call)
![upgit_20250224_1740404013.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250224_1740404013.png)
- 作為user program 與OS之間的溝通介面
- 當user program 執行時，若需要OS提供服務，就需要發出system call通知OS，並由OS執行相對應得service routine，以完成服務。
- user通常看不到system call的細節，都是透過in-line(內嵌支援)或run-time support system(執行期支援系統)的方式為多數程式語言提供一個簡單介面。
- System Call的類型可概分如下:
	- 行程控制(Process Control)
	- 檔案管理(File Management)
	- 裝置管理(Device Management)
	- 資訊維護(Information Maintenance)
	- 通信(Communications)

### 3.2. system 如何將參數傳遞給OS
- 方法01：利用register => 快，但不適用參數過多的情況
- 方法02：將參數利用table或block方式儲存在memory中，並利用register紀錄此table(block)的起始位置，並傳給OS => 慢，但適用於參數較多狀況
- 方法03：將參數push到stack，在藉由OS從stack中pop出來 => 可以用memory或其他硬體來實做stack => 適用於參數較多狀況

### 3.3. Microkernal(微核心)
- 定義：Microkernel 是一種 精簡化的作業系統核心，它將 非必要的功能移除，並交由 System Program（系統程式）或 User Program（使用者程式）來處理。
- 比較：
	- Monolithic Kernel（單核心）：所有功能（如驅動程式、檔案系統、記憶體管理等）都放在核心內，導致核心較大，效能較高但不靈活。
	- Microkernel（微核心）：只保留「最基本」的功能(記憶體管理、進程通訊、排程...)，其他功能（驅動程式、檔案系統等）則交給使用者空間的應用程式處理，提升模組化與安全性。
- 一般而言，Microkernel保留的功能為：
	- basic process management
	- basic memory management
	- process communication
- 主要提供client與user program 與其他server彼此之間通訊便利
- 優點：OS容易擴充
	- OS易於從一個硬體平台轉移到另一個硬體平台上
	- 新加入的system service都是加入到user mode上執行，所以不會影響到kernal(如果有也是小幅度修改)
### 3.4. virtual machine(虛擬機器)
- 定義：透過軟體模擬機制，創造一份【與底層相同的功能介面】
	- 利用cpu scheduling技術創造多顆CPU效果
	- 利用virtual mmory技術擴大memory空間
	- 透過spooling提供多套的IO device，達到IO deivce共用目的
- 對OS而言，VM上得OS只是相當於執行中的一個user program
![upgit_20250224_1740408458.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250224_1740408458.png)

- VM是在monitor mode下運行
	- 優點：在OS中引起得不當錯誤，並不會對實體OS造成危害
	- 缺點：技術困難(難在communicatioin與resource sharing) => 需要借助virtual message passing

![upgit_20250224_1740409017.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250224_1740409017.png)

### 3.5. java 虛擬機器
![upgit_20250301_1740836948.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250301_1740836948.png)

- 大部分程式語言都是基過編譯(compile)或直譯(interprter)
- 然而，java是先經過編譯，再利用直譯的方式才能執行。

## 4. process

| program     | process |
| ----------- | ------- |
| 被動          | 主動      |
| 儲存於disk中的檔案 | 執行中的程式  |

- 定義：正在執行的程式
- 是OS分配資源的一個單位(未執行時，只是一個檔案)
- 包含：
	- code section
	- data section
	- program counter
	- cpu register
	- stack(多個process之間會互相call去從事遞迴，用以存放返回地址)
### 4.1. process狀態圖(process state transition diagram, PTD)
![upgit_20250302_1740849311.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250302_1740849311.png)

- 觸發行為：
	- 當process在memory中時間太長(被block中太久)
	- 其他High Priority來memory搶資源
	- long time I/O device
	- process從disk引入memory中的ready queue
- 一個process的執行時間 = CPU執行時間 + IO等待時間
- process會在CPU brust(CPU bound job)、I/O brust(I/O bound job)上切換，最後終止process的sysytem call來做為process結束。

### 4.2. 行程控制表(process control block, PCB)
- OS為了執行process management，會將所有process的所有相關資訊聚集再一起，形成一個集合(block)
- 包含：
	- process ID
	- process state：process 處於PTD的哪個狀態
	- program counter：表明該process下一個要執行的指令位址
	- CPU register
	- CPU排班資訊資訊
	- memory相關資訊
	- 帳號資訊(用掉多少CPU時間，使用CPU最大時間量etc)
	- IO狀態

> [!NOTE] PCB會存在user area還是monitor area
> OS為了管理process方便，會存PCB在OS所在的moniter area中

### 4.3. 排班程式
- Long-Term Scheduler (或稱Job Scheduler)
	- 從job queue中挑選job，載入到memory
	- 執行頻率最低
- Short-Term Scheduler (或稱Process (CPU) Scheduler)
	- 從ready queue挑選high priority process執行
	- 執行頻率最高(每個process執行時狀況多=>不同情況的interrupt)
	- 各系統的需要(每種系統都需要CPU)
- Medium-Term Scheduler：
	- 當memory不足，又有其他process要進入memory執行時，該scheduler要挑選一些process swap out到disk中，以空出memory space。
### 4.4. context switching
- 當CPU把使用權從processA切換成processB時，需要將舊process的相關資訊儲存起來，並將新process資料載入
- context switching 所花費的時間對系統而言是浪費
	- context switching次數過多，會影響系統效能
	- context switching速度取決於硬體支援速度(memory速度、register數量，特殊機器指令etc)
#### 4.4.1. 如何降低context switching負擔
- 法1：提供多套register set：
	- 若regusster夠多，則每個process都可以有自己的register set
![upgit_20250302_1740924259.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250302_1740924259.png)

- 法2：改用thread代替process
	- 每個process都有自己的PDB，這些資料會占用register
	- 如果使用thread的話，彼此可以共享momory

### 4.5. 分派程式(dispatcher)
- 負責將【CPU控制權】轉交給【經由short term schedular所挑選的process】的功能模組
- 主要工作
	- context switching
	- monitor mode切換到user mode
- dispatcher用來停止一個process，並開始另一個process所消耗的時間，稱為dispatch latency(分派潛伏期/分派延遲)
- dispatch latency越短越好，dispatch latency time越短，新的process可以執行的時間得以越早

![upgit_20250302_1740925212.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250302_1740925212.png)

### 4.6. CPU schedular (CPU排班程式)
- CPU一旦閒置，OS就必須從位於main memory中的ready queue之中挑選其中一個process來執行。
- 從main memory挑選process的工作，是由short-term scheduler來執行
	- OS利用CPU scheduler，從momory中挑選出一個process，透過dispatcher將CPU配置給他
#### 4.6.1. 衡量排班效率的準則：
- CPU Utilization（CPU 使用率）：
	-  CPU 真正在 RUN 的比率是多高
	- CPU Use Time/(CPU Idle Time+CPU Use Time)
- Throughput（產能）：單位時間內 完成的 Job（或 Process）數量
- Waiting Time（等待時間）：
	- Process 在 Ready Queue 等待獲取 CPU 的時間總和
	- 這是 受排班演算法影響最大 的指標
	- 排班策略若不當，可能會導致長時間的等待(starvation)
-  Turnaround Time（完成時間 / 回復時間）：
	- 從 Task（或 Process）進入系統到完成工作 這段時間的總長度
- Response Time（反應時間）：User 提交命令後，系統產生第一個回應的時間

- CPU schedular大致可以分為：
- Non-preemptive(不可插隊)：
	- 當process取得CPU在執行時，除非這個process自願將CPU釋放出來(像是，process結束工作或wait for I/O)，其他process才有機會去取得CPU
	- 在PTD中，從running state到wait state或是terminate皆為Non-preemptive
- preemptive(可插隊)：
	- 當process取得CPU在執行時，有可能被迫放棄CPU(high priority process進入sysytem、中斷發生、CPU time slice)，將CPU交給其他process執行。
	- 在PTD中，從running state到ready state皆為preemptive

### 4.7. starvation(飢餓現象)
- 某些process因為長期無法取得資源來完成工作，造成無窮停滯(infinite blocking)
- 常發生在不公平資源環境，若再加上preemptive更容易發生。
- aging technique(老化技術)：系統每個一段時間，會將系統內閒置過長的process(或為完成的)，逐步提高prierity value

### 4.8. first come first served(FCFS)先到先做排成
![upgit_20250303_1741008234.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250303_1741008234.png)
- arrival time(抵達時間)愈小的process，優先取的CPU控制權
- 容易實作排班效益最差
- 會產生convoy effect(護衛效應)
	- 很多的process都在等待【很長的一段CPU time】，造成平均等待時間大幅增加的不良現象。
- fair
- no starvation
- non-preemptive
### 4.9. shortest job first (SJF)
- process的cpu burst time越少，優先取得CPU控制權
- 理想上，排班效益最佳
- 不會有convoy effect
- not fair => starvation
- non-preemptive
- 不適用於short term sghedular
	- 在SJF中，每個process的cpu burst time是估算的。
	- 但short term sghedular執行效率極高，動不動就在挑選job，很難在短時間內去計算每個process的cpu burst time
### 4.10. shortest remaining time first (SRTF)
- 為preemptive的SJF
- 新到達的process，如果他的CPU burst time 小於目前正在執行的process的remaining time，則可以插隊。
- context switching次數大
- not fair => starvation
- preemptive

### 4.11. priority scheduling(優先權排班)
- 定義：具有較高priority的，先取得CPU控制權
- 定義方式01：內外部
	- 內部：
		- 主要是針對每一個process對資源需求的考量
		- 是OS可以掌握的，像是(記憶體需求、時間限制、開啟檔案的數量)
	- 外部：針對政策面的考量(由人控制) => process的重要性
- 定義方式02：static/dynamic
	- static：當優先權設定給process後就不能再更改
	- dynamic：當優先權設定給process後，還可以更改
- not fair => starvation
- preemptive或non-preemptive
	- preemptive：當某個process到達ready queue後，會與目前正在執行的process比較優先權，若新來的process之優先權較高，會搶走CPU
	- non-preemptive：若新來的process之優先權較高，會將自己放在ready queue的前端


> [!NOTE] priority scheduling與其他排班法則之間的關係
> 主要在於priority的定義
> - 如果以arrival time決定優先權，若arrival time越小，priority越高 => FIFO
> - 如果以CPU burst time決定優先權，若CPU burst time越小，priority越高 => FIFO

### 4.12. round robin(依序時間排班, RR)
- OS會規定某個CPU time slice(時間片段)，當某個process獲取CPU執行，若未能在CPU time slice完成，則此process會被迫放棄CPU
- 作法：
	- 當process取得CPU後，timer的初值會被設為quantum值，隨著process執行，timer值會逐次遞減。
	- 當timer值到達0，會發出中斷"time out"已通知OS。OS會強迫目前process放棄CPU
- fair => no starvation
- preemptive
- RR的排班效益取決於CPU time slice定義
	- quantum過大：退化成FIFO
	- quantum過小：context switching太頻繁，CPU time未真正用在process執行上 => throughtput(產程)過低。
	- 通常80%工作可以在time slice完成，效果越好
### 4.13. multlevel queue(多層queue)
- 定義：根據process不同特性，將main memory所形成的單一qeuue分成不同優先等級的queue
- 每個queue都有各自的scheduling algorithm
- queue之間採取preemptive排班形式
- provess不能在各個queue之間移動

![upgit_20250304_1741094603.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250304_1741094603.png)

### 4.14. multlevel feedback queue
- 定義：與multlevel queue定義相同，差別在【允許process】在各個queue中間移動，必免starvation
- 作法：採取類似paging技術，每隔一段時間將process往上提一層queue
- 在經過有限時間後，lower priority queue => high priority queue
- 也可以做【降級】：當上層queue中的process取得CPU後，若未在quantum內完成工作，則該process在放棄CPU後，會被至於下層的queue當中。
- 在multlevel (feedback) queue中，通常愈上層的queue，其quantum越小。
- not fair => no starvation
- preemptive




#### 4.14.1. 排班演算法整理
- fatr、preemptive、no starvation：RR

| 類別             | 01   | 02                  | 03                        | 04               | 05                        |
| -------------- | ---- | ------------------- | ------------------------- | ---------------- | ------------------------- |
| Preemptive     | SRTF | Preemptive Priority | RR                        | Multilevel Queue | Multilevel Feedback Queue |
| Non-Preemptive | FCFS | SJF                 | Non-Preemptive Priority   |                  |                           |
| No Starvation  | FCFS | RR                  | Multilevel Feedback Queue |                  |                           |
| Fair           | FCFS | RR                  |                           |                  |                           |


## 5. Thread

- 與process相同，也是搶奪CPU的一個基本單位
- process與thread只有內部看的出來，外觀看不出來
- 動機：目前許多PC所執行的程式，都屬於Multi threading
	- 網頁瀏覽器
	- 文書處理
- 每個Thread擁有
	- Thread ID
	- Thread state
	- Thread counter
	- register ser
	- stack
- 同一格process內的Thread彼此分享
	- code section(程式碼區域)
	- data section(資料區域)
	- OS resource(作業系統資源)

![upgit_20250306_1741266239.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250306_1741266239.png)

| Thread | Process |
|--------|---------|
| Light Weight Process | Heavy Weight Process |
| 同一個 Task (或 Process) 內的 Threads 可以共享 Code Section, Data Section, 及 O.S. Resources | 不同的 Process 之間無共享的 Address Space，互為獨立。 |
| Context Switching 負擔輕 | 負擔重 |
| Thread 的管理 (Management) 成本低 (管理項目：Creation, Scheduling, Context Switching...etc.) | 成本高 |
| 一個 Task 內有多條 Threads 存在 | 一個 Task 內只有一條 Thread |
| Process (Task) 內的某 Thread 被 Block，則可切到其它 Thread 執行。此時，若 Process 內只要還有 Thread 在執行，則 Process 不會被 Block | Process (Task) 內的單一 Thread 被 Block，則整個 Process 會被 Block。 |
| 能充分利用 Multiprocessing 架構的效益，因為同一個 Process 的不同 Threads 可以同時在不同的 CPU 執行 | 較無法發揮 SMP 之 Parallel Processing 效益 |
| 必須提供對 Share Data 的互斥存取控制，以防止不正常 Thread 存取所造成之危害 | Process 與 Process 無共享，所以較無必要 |

### 5.1. 利益：
- responsiveness(應答)
	- Multi threading 在一個交談應用中，允許程式中的某一部分被中斷，或執行很久時，該process仍然可以執行。
	- 一個程式只要有一個thread還在run，該process就還可以執行。
- resource sharing：thread之間可以共享process的記憶體跟資源。
- Utilization of Multiprocessing Architecture (使用多處理器架構)
	- 在多處理器架構下執行Multi threading，因為每一個thread可並行在不同處理器上執行，因此Multi threading的利益可以大幅提升
	- 在單一處理器架構上，CPU讓每一格thread可以快速的切換移動，讓uesr誤以為是同時進行。

### 5.2. thread種類
- thread management由誰掌控(create、destory、context switching、scheduling)
- thread可以依照執行時所處模式不同，可以分為
	- user thread：在user mode進行，OS不知道有那些thread存在=>不需要OS介入管理
	- kernal thread：在moniter mode進行，OS知道有那些thread存在=>OS介入管理


|      | user thread                                                    | kernal thread                                                                              |
| ---- | -------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
|      | thread management 由user mode中的執行續程式庫支援                         | thread management由kermal負責                                                                 |
|      | kernal不知道user thread存在                                         | kernal掌握所有thread管理                                                                         |
| 管理成本 | 低                                                              | 高                                                                                          |
|      | thread之間的sgheduling、context switching不需要kernal介入               | slow context switching and creation                                                        |
|      | user thread發送block system call且kernal是單執行續時，會導致整個process被block | - thread發送block system 不會使整個process blocked<br>- 可以安排不同thread在不同CPU平行執行，發揮multiprocessor效益 |

### 5.3. multithread model(多執行續模式)

![upgit_20250306_1741271055.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250306_1741271055.png)

#### 5.3.1. many to one
- 多個user thread對一個kerbal thread
- 執行續主要的管理動作都是在user mode執行，有效率
- 缺點：當任何一個user thread執行暫停的system call，整個process就暫停
- 雖然該模式下，還是可以產生所需要的thread數量，但因為只有一個kernal，OS也一次只能使用一個kernal。無法將block以外的thread分配給其他處理器 => 整個執行續不能多CPU上執行。

#### 5.3.2. one to one
- 每個user thread都對應到一個kerbal thread
- 提供並行運行 => 允許多個thread在multiprocessor上並行運行
- 產生一個user thread時，連帶需要產生一個kernal thread，而kernal thread會對程式執行產生一些負擔 => 需要限制threaf產生的個數

#### 5.3.3. many to many
- 多個user thread對應到多格kernal thread
- 多對一模式可以產生所需要的kernal thread，但因為kernal一次只能執行一個thread，所以數個kernal thread並不能真正的在CPU上並行處理
- 一對一模式雖然可以提供較強的並行處理能力，但不能產出太多的thread
- 多對多模式下，OS可以產生所需要的thread數目，使其在多個CPU上並行處理。另外。當抹格thread執行暫停時，OS可以安排別的thread執行



> [!NOTE] OS分配資源範例
> 有兩processA跟B來分配CPU time
> 以user thread來說，kernal不知道有user thread，所以50%、50%
> 
> 以kernal thread來說，如果有5條thread(processA 3個，processB 2個)
> processA => 60% CPU time
> processB => 40% CPU time



### 5.4. Thread Pool（執行緒池）

- 每當作業系統收到一個請求時，就會產生一個額外的執行緒來處理該請求。
- 多執行緒（Multithread）可以產生很多執行緒，但有數量限制：
	- 產生執行緒需要花費時間（有時間差）。
	- 無限制地產生執行緒可能會耗盡系統資源。
	- Thread Pool（執行緒池）的概念能有效解決此問題。

- 當一個程序（Process）開始執行時，會先產生一些執行緒，並將它們放入執行緒池（Pool）等待工作。
- 當有工作請求產生時，執行緒池會喚醒一個執行緒來處理該請求。
- 當工作完成後，執行緒會回到執行緒池，等待新的工作。
- 如果所有執行緒都在工作，且有新的請求產生，則新的請求需要等待可用的執行緒。
- 優勢：
	- 對於服務來說，使用現存thread比等待一格thread來的快
	- thread pool 限制了任何時間點上的thread個數，不會讓系統資源耗盡(pool中沒有空賢thread時，不會再產生新的thread)
- thread pool數量根據：
		- CPU個數
	- 實際memory大小
	- 預期客戶要求的個數
## 6. 死結
- 定義：系統中存在一組process陷入【互相等待對方所擁有的資源】之情況

![upgit_20250308_1741436628.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250308_1741436628.png)

### 6.1. Dead lock vs starvation
- starvation：在等待的process一直播插隊
- Dead lock：一堆process，在護等資源
- 共同點：都是系統資源分配不當

| Dead Lock                                                 | Starvation                                                           |
| --------------------------------------------------------- | -------------------------------------------------------------------- |
| 由於一組 Processes 形成 Circular Waiting，導致所有 Processes 無法往下執行。 | 由於單一（或少數）Process 因長期取不到資源而形成 Infinite Blocking，但其它 Processes 仍可正常運作。 |
| CPU Utilization 及 Throughput 會大幅降低。                       | CPU Utilization 及 Throughput 不見得會大幅降低。                               |
| 易發生在 Non-Preemptive 的環境。                                  | 易發生在不公平、Preemptive 的環境。                                              |
| 解決：有三大處理方式。                                               | 解決：Aging 技術。                                                         |

### 6.2. 發生dead lock得四個必要條件
- mutual exclusion(互斥)：某資源在同一時間點，只能被一個process所使用(e.g. printer)
- hold an wait：process持有部分資源，且正在等待其他process所持有的資源
- no preemption(不可搶先)：process不可以任意搶奪其他process所持有的資源，別人自願釋放資源才可以用
- circular waiting(循環程式等待)：
![upgit_20250308_1741437838.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250308_1741437838.png)

### 6.3. dead lock處理方式

#### 6.3.1. Dead Lock Prevention
- 優點：保證系統不會進入dead lock
- 缺點：資源利用度低，系統thoughtout偏低
- 方式：只要dead lock得四個必要條件之一，有一個失敗就好啦
	- 打破mutual exclusion：不可能打破，互斥是否些資源本身就具有的性質
	- 打破no preemption：允許process可以搶奪其他wating process手中的資源
		- 頂多starvation，但不會dead lock => (starvation的部分可以用aging處理)
	- 打破hold an wait：(讓hold、wait不會同時發生)
		- 法1：規定【除非process可以一次取得完成工作所需要全部資源，才允許process持有資源，否則process不准持有任何資源】
		- 法2：process在執行開始前可以持有部分資源，但若要再申請資源之前，必須先放掉手中所有資源，才可以提出新資源申請
	- 打破circular waiting：
		- 每個不同類型的資源，皆有獨一的資源編碼(unique ID)
		- process必須按照資源編號遞增方式提出申請


| process持有資源 | 申請資源 | 成功與否 |
| ----------- | ---- | ---- |
| R1, R2      | R5   | 申請成功 |
| R3          | R1   | 申請失敗 |
| R1, R2, R6  | R4   | 申請失敗 |


#### 6.3.2. Dead Lock Avoidance(未完成)
- 當process對資源提出申請時，OS會根據【資訊】執行【銀行家演算法】判斷系統在"假設"申請後，是否處於safe state，如果沒有的話，process就需要在等待一段時間，下一次在提出申請
	- 申請資源數量
	- 各process目前持有的資源數量
	- 各process尚需要的資源數量
	- 系統目前可用的資源數量

![upgit_20250309_1741512610.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250309_1741512610.png)

##### 6.3.2.1. 銀行家演算法（Banker’s Algorithm）

##### 6.3.2.2. 安全演算法（Safety Algorithm）

##### 6.3.2.3. Dead Lock Avoidance重要定理
- 假設系統包含m個單一種類資源，且被n個process共用，如果以下條件滿足，則無deed lock存在
	- 每一個process，的資源最大需求量是否小於m
	- 所有process的資源量加總，需要小於m+n
#### 6.3.3. Dead Lock Detection & Recovery(是一體的)
- 若Dead Lock Prevention跟Dead Lock Avoidance都沒用，則系統可能存在dead lock，必須要提供下列機制：
	- 偵測dead lock是否存在
	- 若dead lock存在，必須打破他
- 優點：resuurce utilization高、thoughtout提升





## 7. process communication
- 同步：某事件的成立與否，會引發一些事件
- OS中，不會只有一個process在OS內，在OS並行執行中的process可以分為：
	- 獨立行程(independent process)：如果一個process無法影響其他process執行，同時也不售其他process影響 => 不會共享任何資料
	- 合作行程(cooperationg process)：如果一個process會影響其他process，也會受其他process影響 => 會共享資料，彼此之間需要有訊息交換與協調的管道。
- process communication的方式
	- Atomic(原子性)是指某個操作能夠在單一時間點被完成，並且不會被其他執行緒或中斷影響。這在 多執行緒（多線程）與並行運算 中非常重要，因為它可以確保「數據不會發生競爭條件（Race Condition）」。

| **比較項目** | **共享記憶體（Share Memory）** | **訊息傳遞（Message Passing）** |
|-------------|--------------------------------|--------------------------------|
| 定義 | Process 彼此之間透過對共享變數的存取，藉由其他進程的變化達到溝通的目的 | Process 之間要溝通，須先建立 Link，建立後才能互相傳送訊息，最後再釋放 Link |
| 共享性 | 共享變數是所有 Process 皆可存取 | Link 是專屬於溝通雙方，不會被其他人共用 |
| 作業系統的支援 | 作業系統僅提供共享記憶體空間，不提供額外支援 | 作業系統會提供 Link 管理等額外支援 |
| 程式設計師的負擔 | 程式設計師負擔較重，作業系統負擔較輕 | 程式設計師負擔較輕，作業系統負擔較重 |
| 必須提供的處理機制 | 需提供對共享變數之互斥存取控制，否則可能發生競爭條件問題 | 需提供 Link 建立、Link 容量控制、訊息遺失處理等機制 |


### 7.1. share momory
- 像是公共信箱(你跟郵差)
- 各個process利用共享記憶體(共享變數)存取，來達到溝通目的
- 提供對memory之互斥存取控制的責任由programmer負責，而OS只負責提供共享的記憶體空間
- 可能會產生競爭情況(race condition)
	- 若未對共享變數提供互斥存取等同步機制，則會造成【因process執行順序不同】而共享變數值不同的情況
![upgit_20250309_1741535605.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250309_1741535605.png)


- 若需要對共享變數進行管制 => 處理rece comdition之策略
	- disable interrupt(停止使用中斷)：
		- 鎖住CPU => 讓使用共享變數的指令可以一口氣做完，而不被interrrupt而干擾
	- critical section design(臨界區間設計)：
		- 鎖住共享變數=>提供對共享變數的存取機制，以確保共享變數在目前使用他的process尚未全部執行完成前，不會被其他process指令所用
#### 7.1.1. disable interrupt(停止使用中斷)

![upgit_20250310_1741588716.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250310_1741588716.png)

- 為了確保共享變數在執行過程中不會被中斷(automically executed)，在執行該指令前，先disable interrupt，執行完後再enable interrupt
- 優點：簡單易用
- 缺點：只適用single processor環境
	- 在multiprocessor下，關掉單科CPU並沒有用，要關掉全部CPU才有用。
	- 所以process必須發出disable interrupt給所有CPU，並要等所有CPU均回覆才可以 => perfomance差且風險高
	- disable interrupt會導致其他更緊急的工作無法執行

#### 7.1.2. critical section design(臨界區間設計)
![upgit_20250310_1741589458.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250310_1741589458.png)
- 提供對共享變數之存取動作的互斥控制。
- critical section：針對【共享變數進行存取的指令】所形成的集合
- critical section design是基於【出口】跟【入口】的程式片段
```
repeat
	entry section // 進入區間
	critical section
	exit section // 離開區間
	remainder section
```

![upgit_20250310_1741590122.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250310_1741590122.png)

#### 7.1.3. critical section design(臨界區間設計)必須滿足的三個條件
- mutual execlusion(互斥)：允許任何時間點，最多只允許一個process進入他的OS
- progress(行進)：
	- 不想進入critical section的process不可以阻礙其他process進入critical section
	- 必須在有限時間內，從那些想進入critical section的process之中，去挑選一個process進入critical section(隱含dead lock)
- bounded waiting(有限等待)：
	- 從process提出critical section申請，到他獲准進入critical section中間的等待時間是有限的
	- 意即：若有n個process想進入critical section，則一個process最多等待n-1次(隱含no stravation)

#### 7.1.4. critical section設計方式
- algorithm base
	- 2個process的方案
	- n個process的方案 => bakery algorithm
- HW指令支援
	- test-and-set 指令
	- SWAP 指令
- semaphore(號誌)
- moniter(監督程式)

#### 7.1.5. Test and Set（測試並設置）
- 是一種硬體提供的同步原語，用於實現「鎖（Lock）機制」。
- 這個指令測試變數的值，如果值為 0，則將其設為 1，表示「該資源已被佔用」

 ![upgit_20250310_1741594850.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250310_1741594850.png)

#### 7.1.6. SWAP 指令
![upgit_20250311_1741678971.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250311_1741678971.png)

#### 7.1.7. semaphore(號誌)
- 用來處理critical section跟同步問題(synchornization problom)的一種data type
- 假設變數S為semaphore，其data type為interger，初值為1
	- 在S上提供了兩個atomic operater，分別為wait(P(s))、singal(V(s))

![upgit_20250311_1741680965.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250311_1741680965.png)

![upgit_20250311_1741680996.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250311_1741680996.png)

- 缺點：programmer可能會誤用semaphore的wait以及signal操作，導致
	- 違反mutual exclusion
	- 造成dead lock
#### 7.1.8. 生產者/消費者問題
- 生產者、消費者(兩者同步)
- 中間會有一個緩衝區(buffer)
	- 無限緩衝區(unbound buffer)：生產者可以無限生產
	- 有限緩衝區(bound buffer)：
- 假設buffer有n個儲存空間
- 宣告3個semaphore
	- mutux：初值為1 => 對buffer提供存取互斥控制
	- empty：初值為n => 紀錄buffer現在空格數
	- full：初值為0 => 紀錄buffer現內有資料的儲存數
- 生產者程式碼
```
repeat 
	produce an item
		wait(empty) => empty會減1(buffer數-1)；若empty為0表示buffer以滿
		wait(mutex)
	add item to button
		signal(mutex)
		signal(full) => full+1，表示buffer+1
until false
```
- 消費者程式碼
```
repeat 
	wait(mutex)
	wait(full) => full-1(buffer數+1)、若full為0，表示buffer以空
		remove itrm from buffer
	signal(mutux)
	signal(mempty)
	produce an item
		wait(empty)
		wait(mutex)
	add item to button
		signal(mutex)
		signal(full) => empty+1，表示buffer-1
until false
```

#### 7.1.9. 哲學家晚餐問題
 ![upgit_20250311_1741682876.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250311_1741682876.png)
#### 7.1.10. moniter
- 為解決同步問題的高階資料結構
- 由三個部分組成：
	- 一處procedure：供外界呼叫使用
	- 共享資料區：此區域會宣告一些共享變數，且只提供給moniter內部的procedure使用
	- 初始區：設定某些共享資料變數的初值
- moniter本身已經確保互斥的性質：每次只允許一個process在moniter移動：
	- 當某個process在執行moniter內的某個procedure時，其他process不可以呼叫/執行moniter內的任何一個procedure，須等到該process執行結束/離開moniter，或因同步條件成立/不成立而被block為指
	- 保證共享資料區裏面的變數不會有rece condition
- 優點：programmer不需花費額外負擔來處理互斥問題。可以把重心放在同步問題決絕上
- 利用moniter解同步問題流程
	- 根據問題，定義moniter
	- 使用moniter：利用所定義的moniter宣告變數

![upgit_20250312_1741781273.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250312_1741781273.png)

![upgit_20250312_1741781717.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250312_1741781717.png)





### 7.2. message passing
- 就像是打電話
- 兩個process溝通需要
	- 建立communication link
	- 互傳訊息
	- 傳輸完畢(release link)
- 此作法需要OS額外支援(link managemant, link capacity, messsage lost處理)，而programmer不需要額外負擔
- 提供兩種操作
	- send()
	- receive()
- 分為兩種聯繫方式
	- direct communication(直接聯繫)
	- indirect communication(間接聯繫)

| **比較項目**               | **Direct Communication** (直接通訊) | **Indirect Communication** (間接通訊) |
| ---------------------- | ------------------------------- | --------------------------------- |
| **溝通條件**               | 雙方需相互指名，才能通訊                    | 雙方需共享 Mailbox 才能通訊                |
| **Communication Link** | 專屬於雙方，不可被其他 Process 共享          | Mailbox 可被多個 Process 共享           |
| **Link 限制**            | 每對 Process 只能有一條 Link，不可有多條     | 雙方可同時存在多條 Link（即 Mailbox）         |

#### 7.2.1. direct communication(直接聯繫)
- process之間的communication link是自動產生的
- process之間需要知道對方身分(identity ID)
- 一條link只能連兩個process
- 又可以分為：
	- symmetric(對稱)
	- asymmetric(非對稱)
##### 7.2.1.1. symmetric(對稱)
- 每一個process必須先確認接收/傳送者的名稱
	- send(P, message)：傳送一個message給P
	- receive(Q, message)：從process Q接收一個message

##### 7.2.1.2. Asymmetric(非對稱)
- 只有發送者需要確定接受者名稱，而接受者不需要指出發送者名稱(位址不對稱)
	- send(P, message)：傳送一個message給P
	- receive(Q, message)：自認何process 接收一個message

![upgit_20250313_1741850002.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250313_1741850002.png)


##### 7.2.1.3. link capacity
- 在message passing中，是否會面臨同步問題
	- 就是buffet為滿/空，消費者/生產者需要停下來的情況
- 嚴格來說，不會，因為message passing並沒有共享記憶體的機制
- 但有類似問題=>link capacity

![upgit_20250313_1741851128.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250313_1741851128.png)

- queue的容量(capacity)：
	- zero capacity：一次只能傳送一個訊息(queue就1格)
	- bound capacity：可以傳送有限的訊息(queue有10格)
	- unbound capacity：可以傳送無限訊息(就是開心一直傳)

##### 7.2.1.4. synchronization 同步化
- 由於massage passing的link capacity，得知massage passing可以是等待(blocking)或非等待(Noblocking)，也可以稱為同步(synchronization)或亦步(Asynchronization)
- 因此，send/receive * blocking/ Noblocking，會有四種操作


|         | blocking                                           | Noblocking                                  |
| ------- | -------------------------------------------------- | ------------------------------------------- |
| send    | blocking send<br>sender會等待，直到receive或mailbox收到訊息為止 | Noblocking send<br>sender送出訊息後，做別的事而非等待     |
| receive | blocking receive<br>receiver會等待，直到收到訊息才往下執行        | Noblocking receive<br>receiver有無收到訊息都可以往下執行 |
- 當接收與傳送之間都有等待時，傳送/接收者之間就會有約會(rendezvous)

![upgit_20250313_1741852237.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250313_1741852237.png)


#### 7.2.2. indirect communication(間接聯繫)

- 需要透過mailbox來傳送/接收訊息
	- send(A, message)：傳送一個message給mailbox A
	- receive(A, message)：從從mailbox A接收一個message
- 只有具有共用的mailbox的process才可以建立link
- 一條link可以連到兩個以上的process
- 進行通訊的process間可以有多條不同的link，且每一個link均動應mailbox

### 7.3. message passing
- 由於message passing這種process通訊管理，是由OS管理，因此需要考慮依些例外情況(exception condition)處理
	- process terminate(行程結束)
	- message lost(訊息遺失)
#### 7.3.1. process terminate
- 無論是接收者還是傳送者，在訊息處裡完成前，都有可能會結束，使得
	- 接收者收不到訊息
	- 傳送者收不到接收者的確認訊號
- 狀況01：接收者正在等待一個【已被中止的process訊息】
	- 如果不對接收者採取行動，就會造成接收者無限期停滯(blocking)
- 狀況02：傳送者正要傳送訊息給一個【已被中止的接收者】
	- 在自動緩衝(automatic buffering)下，對傳送者並無大礙
	- 沒有automatic buffering下，傳送者需要等待接收者的確認訊號，傳送者無限期停滯(blocking)

#### 7.3.2. message lost
- 由於硬體線路故障，導致傳送者往接收者的訊息遺失
- 有兩個工作要做
	- 偵測是否遺失(lost)
	- 遺失的話，是否要重送(resend)
- 處裡以上事件有3種方法：
	- 方法01：由OS偵測訊息是否lost，若有需要，由OS重新傳送 => OS負擔過高
	- 方法02：由傳送的process負責，若有需要，由傳送的process負責重新傳送 => process負擔過高
	- 方法03：由OS負責傳送訊息是否lost，若有需要，OS會告知傳送的process，並由傳送的process重新傳送(較常用)
- 如何偵測lost
	- time-out(限時法)：當message重送出去，會有一個傳送訊息(acknowledgement, ACK)回來，OS會規定一個間隔時間T，若傳送者在2T之內沒收到 => 判定遺失


## 8. 記憶體管理
### 8.1. binding
- 定義：決定程式執行的起始位置=>程式要在記憶體的哪個地方開始執行
- binding的三個時間點：(不同時間點，會有不同效益)
	- Compiling Time(編輯時期)
	- Loading Time(載入時期)
	- Execution Time(執行時期)
![upgit_20250224_1740401839.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/02/upgit_20250224_1740401839.png)

### 8.2. Compiling Time(編輯時期)
- 由Compilier決定
- 將來程式執行得起始位置是固定的(absolute object loader)，不得變更
- 這時的linking loader就只單純負責載入
- 彈性過小
### 8.3. Loading Time(載入時期)
- 由linking loader決定
- linking loader會做4件事：
	- linking：一些程式模組，副程式
	- allocation： 配置程式碼起始位置
	- loading：將程式載入到memory
	- relocation(重定位)：如果載入得位置，有其他程式在=>重新配置程式碼起始位置
- 缺點：
	- 在Execution Time還沒有被呼叫的模組，仍需要事先linking, allocation, loading，浪費時間與浪費記憶體
	```
	if(){
		call A
	}else{
		call B
	}
	
	// module A跟B都需要載入 => 浪費
	```
	- A B兩個模組不可能同時執行，但A B仍需要事先linking load到memory中
	- 對OS影響更大，因為OS有很多錯誤處理程序

### 8.4. Execution Time(執行時期)
- 又稱為dynamic binding
- 在Execution Time才決定程式起始位置
- 程式執行時間，可以任意變更起使位置
![upgit_20250315_1742022973.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250315_1742022973.png)

- 優點：彈性高
- 缺點：程式執行較慢，performace較差

### 8.5. dynamic loading

- 在程式執行期間，當某個模組真正被呼叫到時，才載入到memory中
- 目的：節省memort空間，發揮memory utilization
- 處理Loading Time遇到的缺點
### 8.6. 動態變動分區之memory management
- 在multiprogramming下，記憶體內存有多個process執行(且每個process的size並不相同，進入系統即完成的時間也不同)
- OS採用【contiguous allocation】方式，依據process大小，找到一塊夠大的連續可用空間，配置給process使用
- OS會利用link-list方式保存free block，稱為AV-list(available list)

![upgit_20250315_1742024147.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250315_1742024147.png)

### 8.7. 動態變動分區之memory management方式
- 在探討contiguous allocation的方式
- first-fit：
	- 若所需要的記憶體為n，從AV-list的頭部開始搜尋，直到找到第一個free block size大於n為止
	- 在經過多次配置後，AV-list前端仍會有許多可用的小空間(配置機率極小)，然而每次searchc還是要經過這些區塊，徒增search time => next-fit
- next-fit
	- 從上一次配置後的下一個block開始搜尋，直到找到第一個free block size大於n為止
	- 為first-fit的優化
	- 通常av-list會以circular link list表示
- best-fit：
	- 若所需要的記憶體為n，從AV-list所有block中找出`size>=n && (size-n)最小者`
- worst-fit：
	- 若所需要的記憶體為n，從AV-list所有block中找出`size>=n && (size-n)最大者`
- 無論是哪一種方式，均存在一下問題
	- 外部碎裂問題(external fragmentation)
	- 配置完所剩極小的free block仍會保存在AV-list當中，徒增search time
		- 解法：OS規定一個ε值，若(free block size - process)<ε，就整個free block全給process(有點像是，299給300不用找) =>產生內部碎裂問題
### 8.8. 外部碎裂(external fragmentation)
![upgit_20250315_1742026747.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250315_1742026747.png)
- 在連續性配置方式下，記憶體中的free block的size總和>=process需求大小，但因為這些free block並不連續，因此無法配置
	- memory空間浪費，降低memory utilization
- 解法01：壓縮(compaction)
	- 移動【執行中的process(不是移動空間歐)】，使得不連續的free block得以聚集成一塊夠大的連續可用空間
	- 就像是亂糟糟的停車場，你是移動車，而不是移動停車格
	- ![upgit_20250315_1742028053.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250315_1742028053.png)
	- 蠻難執行的
		- 很難在短時間內決定一個最佳的壓縮策略
		- process必須是dynamic binding才可以支援
	- 解法02：利用page memory mnagement(分頁記憶體管理)


### 8.9. 內部碎裂問題
![upgit_20250315_1742027755.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250315_1742027755.png)

- OS配置給process的空間，大於process實際所需空間
- 這一些空間，該process用不到，其他process也用不到
 

### 8.10. page memory mnagement(分頁記憶體管理)
- 實體記憶體(physical memory)：視為一組frame，每個frame大小均相等
- 邏輯記憶體(logical memory)：
	- 即user program，視為一組page的集合
	- page大小等同於frame大小
- 假設user program大小為n個page，則OS只要在physical memory中找到>=n個free frame即可配置
- 採取【non-contiguous allocation(不連續配置)】=>配置給user program的多個frame不一定要連續 => 處理掉external fragmentation
- OS會為每一個process建立一格page table，紀錄每一個page被載入的frame編號(或起始位置)

![upgit_20250316_1742117714.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250316_1742117714.png)

- logical address轉換成physical address過程
	- CPU送出一個單一值的logical address
	- logical address會被拆成
		- p：page
		- d：page offset
	- 根據p去查page table，取得該page之對應frame的起事編號
- 優點：
	- 處理外部碎裂(external fragmentation)
	- 支援share memory、protection

![upgit_20250317_1742199814.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250317_1742199814.png)

![upgit_20250317_1742200330.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250317_1742200330.png)

- 缺點：
	- memory存取時間較長
	- 需要額外硬體支援：page table、搜巡器、加法器
	- 會有內部碎裂問題
		- 若page size = 4bk，user program = 21k => 需配置6個frame，且產生3kb的internal fragmentation
		- 若page size = 100bk，user program = 101k => 需配置2個frame，且產生99kb的internal fragmentation
	
### 8.11. 實作page table
- 使用TLB(transaction lookside buffer)來保存常用page table，而完整的page 存在memory中
- 先到TLB查詢
	- HIT：輸出frame起始位置
	- MISS：再到memory中取出page table 

![upgit_20250317_1742201969.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250317_1742201969.png)

### 8.12. segmant memory management(分段記憶體管理)
- 實體記憶體(physical memory)：
	- 不需要事先區分記憶體空間
	- 若memory中存在process所需要的連續夠大之free memory space，
- 邏輯記憶體(logical memory)：
	- 即user program，視為一組segment的集合
	- 每個segment大小不一
		- main segmant
		- subroutine segmant
		- data segmant
		- ....
	- segment對mamory的看法與user一致
- 配置方式
	- 在segment與segment之間，可以採用【不連續配置】
	- 對於單一segment，是採【連續性配置】
- OS會替每個process準備segment table，來記錄各segment的大小(limit)，以及各segment仔入的memory起始位置。

![upgit_20250318_1742302184.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250318_1742302184.png)

- logical address轉換成physical address過程
	- CPU送出一個兩個值
		- s：segment
		- d：page offset
	- 根據s去查segment table，取得該segment的limit
	- 若d小於limit(表示可以安全存取)
		- 若OK，取出該segment的base => d+base即為physical address
		- 不OK，表示illegal memory access

![upgit_20250318_1742303074.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250318_1742303074.png)

- 優點：
	- 沒有internal fragmentation問題
	- 可支援memory的sharing與protection=>比分頁更容易，若sharing與protection的要求較高，可以用segmant memory management
	- 可支援dynamic loading 跟virtual memmory操作
- 缺點：
	- 有external fragmentation問題
	- 記憶體存取時間較長
	- 需要額外硬體支援

![upgit_20250319_1742374410.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250319_1742374410.png)

| **特性**        | **Paging（分頁）**                         | **Segment（分段）**                       |
| ------------- | -------------------------------------- | ------------------------------------- |
| **大小**        | 每個 Page 大小相同                           | 各 Segment 大小不一定相同                     |
| **內部/外部碎片問題** | 有 **Internal Fragmentation（內部碎片）** 問題  | 有 **External Fragmentation（外部碎片）** 問題 |
| **與使用者視角**    | 與 **User** 對 Memory **看法不一致**          | 與 **User** 對 Memory **看法一致**          |
| **邏輯位址表示**    | **Logical Address** 為**單一值**           | **Logical Address** 為**兩個值（s, d）**    |
| **界限檢查**      | 無需 Check `d < Page Size`               | 需 Check `d < Segment Limit`           |
| **記憶體共享與保護**  | Memory **Sharing 及 Protection** 實作上較困難 | Memory **分段較容易**                      |
| **頁表/分段表**    | **分頁表** 不需存放 Page 大小                   | **分段表** 需存放 Segment 限制（Limit）         |

### 8.13. paged segment memory management(分段式分頁)
- 先分segment，再分page
- user program 由一組segment組成，每個segment由一組page組成
- 每個process會有一個segment table，每個segment由一個page table

![upgit_20250319_1742375454.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250319_1742375454.png)

![upgit_20250319_1742375479.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250319_1742375479.png)

![upgit_20250319_1742375500.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250319_1742375500.png)

- 沒有external fragmentation problom
- 有internal fragmentation problom
- table數目多=>占空間
- memory access time更長


## 9. 虛擬記憶體
目的：允許program size大於physical memory size情況下仍能運行
採用partial loading 概念
- dynamic loading：
	- 在執行期間，當副程式真正需要被call到，才把牠放到memory中
	- 造成programmer負擔：OS只提供loader，只有programmer知道哪些程式互斥
- virtual memory：OS負擔，programmer無負擔
優點：
- 記憶體的每個小空間都會被利用到，memory utilization上升
- 盡可能提高multiprogramming degree，memory utilization上升
	- 程式不用將所有page搬到memory才能執行
### 9.1. Demand Paging 技術  
- 實現virtual memory
- 基於page memory management所發展，不同之處=>採用lazy swapper
	- 程式執行的時候，並不是將全部page仔入memory，而是僅載入執行時所需的page到memory，其餘page至於blocking store中
	- 若執行所需page都在memory中=>正常
	- 若發生page fault，由OS另行處理

#### 9.1.1. 分頁表(page table)之配合修正
- 多加一個valid/invalid bit欄位，表示page是否在memory中
![upgit_20250320_1742464483.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250320_1742464483.png)

### 9.2. Page Fault 處理  
- OS收到page fault所引起的interrupt(由memory management unit發出)
- OS暫停目前process執行，並保存此process狀態
- OS判斷page fault的memory access位址是否合法
	- 非法：終止此process
	- 合法：表示由page fault引起
- OS去memory檢查，有無free frame
	- 若無，執行page replacement以空出一個free frame
- OS去disk找到lost page之所在位置
- 將lost page載入到free frame
- 修改page table(指名此page所在的frame，並將invalid改成valid bit)
- 恢復原先process
#### 9.2.1. virtual memory效益評估
- 由effective memory acess time決定
- `effective memory acess timer = (1-p)*ma + p*(page fault processing time)`
	- p：page fault ratio
	- ma：正常的memory acess time
	- page fault processing time：page fault 處理程序的所有工作時間總和
- 若要降低effective memory acess time，則需要降低page fault ratio
### 9.3. Effective Memory Access Time  
### 9.4. 影響 Page Fault Ratio 因素
- page replacement 演算法
- frame數量分配多寡
- page size大小
- program structure：要選擇合適的資料結構(演算法)



### 9.5. Page Replacement Algo
- OS必須選擇一個犧牲者(victim page)，將其swap out到disk以空出一個free frame
- 再將lost page swap in 到frame
- swap in、swap out分別是兩個IO動作
- 問題
	- disk IO動作是否可節省
	- 如何挑犧牲者
		- swap in是必須要做的
		- swap out不一定要做，視victim page是否曾被修改
	- 如果victim page從執行開始到被替換前，都沒有被修改過(或寫入)，就可以被直接覆蓋
	- 判斷依據：利用"modification bit"紀錄
		- 0：表示未被修改過=>不用swap out
		- 1：以修改

- pure demand paging：
	- 程式執行初，不會載入任何page
	- 缺點：執行初會產生大量page fault
	- 優點：載入page階是process所需要的頁面，故後續的page fault ratio會下降至合理
- prepaging(預先分頁)
	- 事先猜測程式執行初期，先猜會使用那些page，並先把這些page載入近來
	- 猜準：避免程式初期大量page fault
	- 猜錯：
- 下面是針對Page Replacement Algo.  

#### 9.5.1. FIFO
![upgit_20250321_1742534735.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250321_1742534735.png)

- 最先載入的page先當victim
- 簡單，好實作
- 效率差(page fault radio高)
- 可能碰到belady現象：當process分配到較多的frame數目，page fault radio 不減反升

![upgit_20250321_1742535049.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250321_1742535049.png)

#### 9.5.2. OPT
- 長期不會使用的page"視為victim
- 以未來的角度，很理想但做不到
#### 9.5.3. LRU
- 將"最近不常使用的page"視為victim：
- 製作方式：(1)使用counter。(2)使用stack
#### 9.5.4. LRU近似法則
- 來源：LUR製作成本過高
- second chance(二次機會法則)
	- 以FIFO作為基礎，搭配reference bit
	- 先以FIFO挑出page，檢查reference bit
	- 1：表示最近有被參考過=>將bit改為0，重新挑
	- 0：表示最近沒有被參考過=>victim page
	- 若所有page的reference bit都是0或都是1，就跟FIFO依樣=>可能會有belady現象
- enhance second chance(增強二次機會法則)
	- 基於second chance
	- reference bit變成二進位(00、01、10、11)
### 9.6. Frame Allocation Limitation  
- frame數量分配多寡
- 理論上，process所分配到的frame數目越多，page fault ratio越低
- process所分配之frame數目有最少數目跟最大數目的限制，數目限制均取於硬體因素
	- 最多數目的限制：由實際記憶體大小決定
	- 最少數目的限制：由機器指令結構決定=>必須要讓任何一條機器指令完成

### 9.7. Thrashing 及其解決方式  
- thrashing(震盪)
	- 在multiprogramming且為demand paging環境中，若process分配到的frame數目不足，經常會發生page fault，此時需要執行page replacement
	- 若採用【global replacement policy】：選victim時可選擇別人的page替換出去
	- 若採用【local replacement policy】：選victim只能選自己的page替換出去
- 所有process忙於處裡page swap in & out => CPU idle => CPU utilization下降 => OS會企圖引入更多process近來 => free frame不足

![upgit_20250321_1742547721.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250321_1742547721.png)

降低方式
- 降低multiprogramming degree
- 利用page fault radio來防止thrashing=>OS規定合理的page fault radio上下限
	- 若某process的page fault radio大於上限=>OS需要分配額外的frame給process
	- 若某process的page fault radio小於下限=>OS應該從process中取走多餘的free frame，以分配給其他有需要的process
![upgit_20250321_1742547919.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250321_1742547919.png)

### 9.8. Page Size 之影響  
Page Size越小，則
- page fault radio越大
- page table size越大
- IO time(整個執行的process IO time愈大)
- 內部碎裂愈小

## 10. 磁碟與檔案管理
### 10.1. Free Space Management(可用空間管理)
![upgit_20250322_1742647175.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742647175.png)

- disk allocation/free space單位為block
- 用一組bit來代表block配置與否(0代表free block)
- 管理方式01：bit vector
	- 可以列出bit vector：0011001011000001
	- 優點：容易找到連續空間(就是連續一段0)
	- 缺點：bit vector很佔memory空間(不適用於大型disk)
- 管理方式02：link list
	- 優點：加入/刪除容易
	- 缺點：效率不佳
- 管理方式03：combination(結合法)
	- 取某一個block，紀錄其他block的編號=>這些block再以linklist連接
![upgit_20250322_1742647681.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742647681.png)

- 管理方式04：counting
	- 適用於連續區塊較多，在一個free block中，紀錄其後面連續的free block數目(包括自己)
	- 如果連續數目block夠多，則linklist長度可以大幅縮短
![upgit_20250322_1742647966.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742647966.png)


### 10.2. Disk Access Time
由下列3個時間加總
- seek time：將讀寫頭移到指定track上方時間
	- 耗時最多(因為是機械動作)
	- 延伸disk scheduling algo(磁碟排班演算法)
- latency time：將要access的sector轉到讀寫頭下方所花費的時間
- transfer time：資料在disk及memory之間傳輸
### 10.3. Disk Scheduling Algorithms
- 範例依據
- 目前讀寫頭在53，讀寫要求為98、183、37、122、14、124、65、67
![upgit_20250322_1742648893.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742648893.png)

#### 10.3.1. FCFS(first-come first-serve)
![upgit_20250322_1742649136.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742649136.png)

- 簡單、公平、效能不佳

#### 10.3.2. SSTF(shori-seek time first)
![upgit_20250322_1742649409.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742649409.png)

- 距離讀寫頭最近的優先服務
- 並非最佳
- 不公平，可能會發生starvation
	- 若後續進來的track請求都在讀寫頭附近的話，距離讀寫頭最遠的track會starvation

#### 10.3.3. SCAN
![upgit_20250322_1742649772.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742649772.png)

- 提供雙向服務
- 讀寫頭來回不停掃描(遇到頭/尾端才折返)，若有track請求就服務
- 會有不必要的磁軌移動產生
- 相對不公平，但不會發生starvation
#### 10.3.4. C-SCAN
![upgit_20250322_1742650306.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742650306.png)

- 提供單向服務
- 會有不必要的磁軌移動產生
#### 10.3.5. LOOK
![upgit_20250322_1742650644.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742650644.png)

- 提供雙向服務
- 處裡完某方向的最後一個track，即折返服務
- 相較於SCAN，不會到頭/尾端

#### 10.3.6. C-LOOK
![upgit_20250322_1742650785.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742650785.png)

- 提供單向服務
- 處裡完某方向的最後一個track，即折返服務
- 相較於SCAN，不會到頭/尾端
### 10.4. Allocation Methods(檔案配置方式)

#### 10.4.1. Contiguous Allocation
- 若file大小為n個block，則OS必須在disk找到大於等於n個連續free block才能配置
- physical directory記錄方式：【file neme, size, start block#】
	- physical directory是給OS看
	- logical directory是給oser看
![upgit_20250322_1742654077.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742654077.png)

- 優點：
	- 支援sequential access跟random access
	- seek time通常較短(file所佔的連續block通常都會落在同一個(或附近)的track)
- 缺點：
	- 易受到外部碎裂(external fragementation problom)：若有1個file要求7個block，disk中可用的blocl有10個，卻因為空間不連續而無法分配給file
	- 檔案大小任意增加/刪除：有些file是動態的。若某一位置已被配置動態檔案，且其前後空間已配置其他檔案，則無法動態增加該檔案資料
#### 10.4.2. Linked Allocation
- 若file大小為n個block，則OS必須在disk找到大於等於n個block(不一定要連續)，彼此之間用link做串連
- physical directory記錄方式：【file neme, start block#, end block#】
![upgit_20250322_1742655649.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742655649.png)

- 優點：
	- 沒有外部碎裂(external fragementation problom)
	- file可任意增加/刪除
	- 建檔時，無法事先宣告大小
- 缺點：
	- 讀取file的某的block時，因為是linklist，所以只能sequence access，不能random accesss
	- seek time比Contiguous Allocation長
#### 10.4.3. FAT
- 是Linked Allocation的變形
- 將所有配置block之間的link與free block全部記錄在一個table中，這個table稱之為FAT
- 若disk有n個block，則FAT有n個項目(無論是free還是used都要記錄)
- FAT紀錄資訊
	- empty：free block
	- 某個block#：有link指向此block
	- EOF：end of file
![upgit_20250322_1742657171.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742657171.png)

#### 10.4.4. Index Allocation
- 每個file都會多配置一些額外的block作為index blocks，內涵各配置的data block編號
- 採非連續性配置方式
- physical directory記錄方式：【file neme, index block#】
![upgit_20250322_1742657345.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742657345.png)

- 優點
	- 沒有外部碎裂(external fragementation problom)
	- 支援sequential access跟random access
	- 建檔時，無須事先宣告大小
	- file可以任意增加/刪除
- 缺點：
	- index block占空間
	- index block空間設計，是一個問題
#### 10.4.5. index block不夠大
- 解法01：利用多個index block存，index block之間用linklist串
	- 適用於小檔案
![upgit_20250322_1742657661.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742657661.png)

- 解法02：multilevel index(多層索引)
	- 僅適用於大型檔案，小檔案不合適
	- 一旦系統索引卻認為2level，無論檔案大小，都是使用2level，搞不好index大小會大於檔案本身
![upgit_20250322_1742657756.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742657756.png)

- 解法03：混合法(unix使用之i-node structure)
	- 假設有15個東西(pointer)
	- 1-12號存data block#
	- 13號指向single-level block
	- 14號指向two-level block
	- 15號指向three-level block
![upgit_20250322_1742658232.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250322_1742658232.png)

### 10.5. RAID(磁碟陣列)
- 硬碟(hard disk, HDD)是磁碟(disk)的一種，但不是所有磁碟都是硬碟
- 在OS中，以硬碟disk效率最差(機械式運作)
- RAID是由多顆磁碟機組成陣列(邏輯磁碟)，將資料以切割的方式，同時對不同的磁碟做讀寫
	- 一個byte的資料原本存在一個disk
	- 若切成8個bit，並分散存放於8個disk上，在依次單位時間上，則可獲得8倍的傳輸速率
- 採平行IO以提升效率
- 由OS進行資料的切割(script)與分散存取，故user僅看到一個大且速度快的邏輯磁碟空間(logical disk)
- 依據技術不同給編號：RAID0、RAID1、etc
	- 編號與系統效能無關，純看管理員需求
### 10.6. 錯誤碼的偵測與更正
#### 10.6.1. 同位元檢查(parity check)：偵測能力
- 偶同位(even parity)：訊息加上parity check bit所形成的傳輸碼中，bit 1的個數需要為偶數才正確
- 奇同位(odd parity)：訊息加上parity check bit所形成的傳輸碼中，bit 1的個數需要為奇數才正確
- 簡單，容易實作
- 若有偶數個bit同時出錯則無法偵測

```
假設以偶同位
若訊息為1101000 => parity check為1
若訊息為0110011 => parity check為0
```

#### 10.6.2. 漢明碼(hamming code)：偵測&修正能力
- 傳輸碼 = 傳送訊息 + hamming code bit

#### 10.6.3. RAID0
- 又稱為Striping RAID
- 最少需要 2 顆磁碟
- 將資料切割後分散存放到多顆硬碟中
- 資料以「交錯（Stripe）」的方式分散，例如：
	- Block1 ➜ 磁碟1
	- Block2 ➜ 磁碟2
	- Block3 ➜ 磁碟1
	-  以此類推...
- 效能導向：可平行讀寫，但完全沒有容錯能力
	- 只要有一顆磁碟壞掉 ➜ 所有資料都會毀損
![upgit_20250323_1742732121.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250323_1742732121.png)

#### 10.6.4. RAID1
- 又稱：Mirror RAID（鏡像備份）
- 當有資料寫入時，同時寫入兩顆硬碟
	- 兩顆硬碟中的資料是完全一樣的
- 若一顆硬碟故障：另一顆硬碟可讓系統正常運作
![upgit_20250323_1742733346.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250323_1742733346.png)

#### 10.6.5. RAID2
- 為RAID0的改良，以漢明碼的方式進行資料邊碼
- 不同的位元存在不同的硬碟中
	- eg：4個bit的資料，需要7個硬碟儲存(3個存漢明碼)
- 具有錯誤及修正能力，當其中一個硬碟壞掉，可以尤其硬碟修正

![upgit_20250323_1742733411.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250323_1742733411.png)
#### 10.6.6. RAID3：parallel with parity(平行同位元檢查)
- RAID3、RAID4、RAID5都是基於平行同位元檢查
- 資料切割以bit為單位=> RAID4以block為檢察單位
- 以同位元檢查為容錯機制 
- 所有的同位元資料皆存放在同一棵硬碟上
![upgit_20250323_1742733659.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250323_1742733659.png)

- RAID5把同位元分散儲存在各磁碟內
![upgit_20250323_1742733755.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2025/03/upgit_20250323_1742733755.png)

## 11. 固態硬碟(solid state disk, SSD)

| 分類    | 固態硬碟（SSD）                                                    | 傳統硬碟（HDD）                                                  |
| ----- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 📌 優點 | - 電子式資料讀寫 → 抗震性佳 <br>- 適用於行動裝置 <br>- Random Access → **速度快** | - 成本低 <br>- 容量大                                            |
| ⚠️ 缺點 | - 成本高 - 容量小                                                  | - 機械式資料讀寫 → 抗震性差 <br>- Header 移動 → **速度慢** <br>- 適用於桌機或 NB |
