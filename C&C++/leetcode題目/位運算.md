### 67. Add Binary
```cpp
class Solution {
public:
    string addBinary(string a, string b) {
        string ans = "";
        // 反轉
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());
        // 找最大數->知道要加幾次
        int n = max(a.size(), b.size());
        int carry = 0; // 進位
        for(int i=0;i<n;i++){
            // 處理a的位元
            if(i<a.size() && a[i]=='1') carry+=1;
            // 處理b的位元
            if(i<b.size() && b[i]=='1') carry+=1;

            // ans處理結果
            if(carry%2==1) ans += '1';
            else ans += '0';

            carry/=2;
        }

        // 處理carry最後
        if(carry) ans += '1';
        reverse(ans.begin(), ans.end());
        return ans; // 返回最終結果

    }
};
```
### 190. Reverse Bits
![upgit_20241120_1732093818.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241120_1732093818.png)
```c
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t ans = 0;
        for(int i=0;i<32;i++){
            ans = (n&1) + (ans<<=1);
            n>>=1;
        }
        return ans;
    }
};
```
### 191. Number of 1 Bits
- 先轉乘二進位，在計算幾個1
```cpp
class Solution {
public:
    int hammingWeight(int n) {
        int ans = 0;
        for(int i=0;i<32;i++){
            if(n&1 == 1) ans ++;
            n>>=1;
        }
        return ans;
    }
};
```
### 231. Power of Two
- 解法1：用乘法的方式
```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n==0) return false;
        int ans = 1;
        for(int i=0;i<31;i++){ // 當ans為1時，代表已經位移1次了
            if(ans==n) return true;
            ans<<=1;
        }
        return false;
    }
};
```
- 解法2：用除法的方式
```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n==0) return false;
        while(n%2==0){
            n>>=1;
        }
        return n==1;
    }
};
```
- 解法3：利用n&(-n)取得最低位元1，再去XOR檢查
![upgit_20241121_1732193850.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241121_1732193850.png)


```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        return n > 0 && (n ^ (n & -n)) == 0;
    }
};
```

### 342. Power of Four
- 檢查是否為4的次方=>檢查開跟號後是否為2的次方
```cpp
class Solution {
public:
    bool isPowerOfFour(int n) {
        if(n<0) return false;
        int x = (int)sqrt(n);
        return pow(x,2)==n && n && (x & -x) == x;
    }
};
```
### 338. Counting Bits
- 計算範圍內，每個數(二進位)1的數量。
- 解法1：就乖乖一個一個去數
```cpp
class Solution {
public:
    // 計算幾個1
    int getCnt(int u){
        int ans = 0;
        for (int i = 0; i < 32; i++){
            ans += (u & 1);
            u>>=1;
        }
        return ans;
    }

    vector<int> countBits(int n) {
        vector<int> ans(n + 1);
        for (int i = 0; i <= n; i++) {
            ans[i] = getCnt(i); // 計算每個數字的 1 的數量
        }
        return ans; // 返回結果向量
    }
};
// Your runtime beats 36.25 % of cpp submissions
// Your memory usage beats 77.05 % of cpp submissions (9.3 MB)
```
- 解法2：Brian Kernighan演算法(針對解法1進行優化)
![upgit_20241121_1732191249.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241121_1732191249.png)
```cpp
class Solution {
public:
    // 計算幾個1
    int getCnt(int u){
        int count = 0;
        while(u>0){
            u = u&(u-1);
            count++;
        }
        return count;
    }

    vector<int> countBits(int n) {
        vector<int> ans(n + 1);
        for (int i = 0; i <= n; i++) {
            ans[i] = getCnt(i); // 計算每個數字的 1 的數量
        }
        return ans; // 返回結果向量
    }
};
// Your runtime beats 100 % of cpp submissions
// Your memory usage beats 90.46 % of cpp submissions (9.2 MB)
```
- 解法3：DP
![upgit_20241121_1732192960.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241121_1732192960.png)

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        int highBit = 0;
        for (int i = 1; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                highBit = i;
            }
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
};
```
### 401. Binary Watch
![upgit_20241122_1732261033.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241122_1732261033.png)

- 給你一個數字，他代表只能亮的燈數，阿你要返回所有可能
- 他給的燈數，代表說你要去計算【每個時間點，他轉成二進位後的1的各數】(就代表說，亮幾個燈)
```cpp
class Solution {
public:
    // 給一個整數，返回該數轉二進位後有幾個1
    int f(int n){
        int ans = 0;
        while(n){
            n = n&(n-1);
            ans++;
        }
        return ans;
    }

    vector<string> readBinaryWatch(int turnedOn) {
        vector<string> ans;
        for(int i=0;i<12;i++){
            for(int j=0;j<60;j++){
                string hour, min;
                if(f(i)+f(j)==turnedOn){
                    hour = to_string(i);
                    // 分的格式比較特別，處裡一下
                    if(j<10) min = "0"+to_string(j);
                    else min = to_string(j);
                    ans.push_back(hour+":"+min);
                }
            }
        }
        return ans;
    }
};
```
### 461. Hamming Distance
- 漢明距離：兩個數值轉二進位後，两个数字在二进制表示中有多少位是不同的。
![upgit_20241122_1732261928.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241122_1732261928.png)

![upgit_20241122_1732261941.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241122_1732261941.png)

```cpp
class Solution {
public:
    // 給一個整數，返回該數轉二進位後有幾個1
    int f(int n){
        int ans = 0;
        while(n){
            n = n&(n-1);
            ans++;
        }
        return ans;
    }

    int hammingDistance(int x, int y) {
        // 先做XOR
        int n = x^y;
        return f(n);
        
    }
};
```
### 476. Number Complement
- 10轉反(但不+1)
- 解法1：模擬(這一題的難度是，你不知道他的最高位到哪裡，所以要先用遮罩做出來)。
![upgit_20241122_1732264090.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241122_1732264090.png)

```cpp
class Solution {
public:
    int findComplement(int num) {
        int mask = 0;
        int temp = num;
        
        // 創建一個全是 1 的遮罩，遮罩的長度等於 num 的二進位長度
        while (temp > 0) {
            mask = (mask << 1) | 1;
            temp >>= 1;
        }

        // 使用遮罩反轉 num 的位元
        return (~num) & mask;
    }
};
```

### 645. Set Mismatch
![upgit_20241122_1732265777.png](https://raw.githubusercontent.com/kcwc1029/obsidian-upgit-image/main/2024/11/upgit_20241122_1732265777.png)
- 解法1：紀錄(看你要用vector或map都可以)
```cpp
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        int duplicate = 0;
        int missing = 0;
        int n = nums.size();
        map<int, int> m;
        for(int i=0;i<n;i++){
            m[nums[i]]++;
        }
        for(int i=1;i<n+1;i++){
            if(m[i]==2) duplicate = i;
            if(m[i]==0) missing = i;
        }
        return {duplicate, missing};
    }
};
```
- 解法2：排序
	- 重複的數字：若 curr == prev，表示當前數字重複
	- 丟失的數字：若 curr - prev > 1，表示中間缺少一個數字，應記錄為丟失數字 prev + 1。
```cpp
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        int duplicate = 0, missing = 0;
        int n = nums.size();
        int prev = 0;
        sort(nums.begin(), nums.end()); 
        for(int i=0;i<n;i++){
            if(nums[i] == prev) duplicate = nums[i];
            if(nums[i] - prev>1) missing = prev +1;
            prev = nums[i]; // 更新 prev
        }

        // NOTE: [1,1]時要額外處裡
        if (nums[n - 1] != n) missing = n;
        return {duplicate, missing};
    }
};
```



